---
title: "[译] 超文本传输协议 HTTP/1.1"
description: 本文规定了互联网社区的标准跟踪协议，接受讨论和建议使之更加完善。有关本协议的情况和标准化状态，请参考当前版本的"互联网官方协议标准"(STD 1)。本文对发布无限制。
date: 2019-07-20T09:08:27+08:00
image: 
math: 
license: 
hidden: false
comments: true
draft: true
categories:
    - Tech
tags:
    - HTTP
    - Translation
---

## 原文地址

https://greenbytes.de/tech/webdav/rfc2616.html

## 文章状态
本文规定了互联网社区的标准跟踪协议，接受讨论和建议使之更加完善。有关本协议的情况和标准化状态，请参考当前版本的"互联网官方协议标准"(STD 1)。本文对发布无限制。

## 版本声明

Copyright © The Internet Society (1999). All Rights Reserved.

## 摘要

超文本传输协议(HTTP)是一份适用于分布式，合作式，超媒体信息系统的应用层协议。它是一种通用的无状态协议，可以通过拓展其请求方法，错误代码和请求头，来实现很多不限于超文本的任务，比如为服务器和分布式对象管理系统命名等。数据表示的输入和内容协商是HTTP的一个特性，它允许系统可以独立于正在被传输的数据而构建。

## 目录
* [1.简介](#1-简介)
    * [1.1 目的](#11-目的)
    * [1.2 要求](#12-要求)
    * [1.3 术语](#13-术语)
    * [1.4 全局操作](#14-全局操作)
* [2.符号惯例和基本语法](#2-符号惯例和基本语法)
    * [2.1 BNF 扩充](#21-bnf-扩充)

## 1. 简介

### 1.1 目的

超文本传输协议(HTTP)是一份适用于分布式，合作式，超媒体信息系统的应用层协议。万维网全球信息倡议从1990年开始使用 HTTP 协议，一直沿用至今。被称为 HTTP/0.9 的第一版 HTTP 协议只是简单地实现了将原始数据通过网络进行传输。RFC 1945 中定义的 HTTP/1.0 改进了第一版协议，它允许传输以类似MIME格式排版的信息，这种格式需要包含被传输数据的元信息，以及请求/响应语义的标识符。但是，HTTP/1.0 对于分层代理、高速缓存、需要持续连接和虚拟主机等带来的影响没有充分的考虑。

另外，由于那些自称 HTTP/1.0 实际上并没有完全实现其功能的应用程序的激增，这使得我们必须再进行一次版本更改，来确定内容协商双方应用程序的真实能力。

这份规定将协议定义为 HTTP/1.1。新协议比 HTTP/1.0 包含更多严格的要求，来确保应用对协议功能的实现可以信赖。

实用信息系统除了简单检索还需要更多的功能来支撑，包括搜索，前端更新和注释。HTTP允许请求用一组开放式的方法和标头来表示本次请求的目的。这个特性建立在统一资源标识符(URI)提供的引用规则之上，它以一个地址(URL)或者名称(URN)来标识正在申请使用方法的是哪一个资源。消息以类似网络邮件的格式进行传递，这种格式被称为多用途互联网邮件扩展(MIME)。

HTTP 也被一些支持 SMTP, NNTP, FTP, Gopher 和 WAIS 的其他互联网系统用于实现用户代理(User Agent)和代理服务器/网关(Proxies/GateWays)之间的通信。这样一来，HTTP 就可以允许基本的超媒体访问来自不同应用程序的资源。

### 1.2 要求

本文中的关键字"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL"将按照 RFC 2119 的描述进行解释。

协议的实现必须满足所有的 MUST 和 REQUIRED 级别的要求，否则这个实现与协议不兼容。满足所有 MUST, REQUIRED 和 SHOULD 级别要求的实现被称为协议的"无条件遵守(unconditionally compliant)"。满足所有 MUST 要求和一部分 SHOULD 要求的实现被称为协议的"有条件遵守(conditionally compliant)"。

### 1.3 术语

本文使用了大量的术语来指代参与HTTP通信内容协商的对象或角色。

#### 连接 (connection)
> 为实现程序间的通信，在彼此之间构建的传输层虚拟回路。
#### 消息 (message)
> HTTP通信的基本单位，通过连接传输，由与第4节定义的语法相匹配的结构化八字节序列组成。
#### 请求 (request)
> HTTP的请求消息。在第5节有定义。
#### 响应 (response)
> HTTP的响应消息。在第6节有定义。
#### 资源 (resource)
> 可以用 URI 来区分的网络数据对象或服务。在第3.2节有定义。资源可以有多种表现形式(如，不同的语言、数据格式、大小或分辨率)，或者以其他的方式变化。
#### 实体 (entity)
> 请求或响应在传输过程中负载的信息。实体包含两部分，分别是置于实体头部的元信息和置于实体主体部的内容。在第7节有描述。
#### 表现形式 (representation)
> 依赖于内容协商的响应中的实体。在第12节有描述。可能存在多种表现形式，这取决于特定的响应状态。
#### 内容协商 (content negotiation)
> 处理请求时选择适当表现形式的机制。第12节有描述。每个请求中实体的表现形式都可以被协商(包括错误的响应)。
#### 变体 (variant)
> 在任何给定时刻，与资源对应的表示方法可以有一个或多个，每个表示方法称为一个变体。不是只有在资源经过内容协商后才可以使用变体。
#### 客户端 (client)
> 创建连接，发送请求的程序。
#### 用户代理 (user agent)
> 发送请求的客户端。一般是浏览器，编辑器，爬虫或者其他用户工具。
#### 服务器 (server)
> 接收连接，处理请求，返回响应的应用程序。任何程序都既能做客户端也能做服务器，我们使用这些术语仅指代程序在特定连接中扮演的角色，而不是程序的一般功能。同样，任何服务器都可以充当源服务器，代理服务器，网关或者隧道，服务器会根据请求的不同性质来切换不同的行为。
#### 源服务器 (origin server)
> 存放资源或将要创建资源的服务器。
#### 代理服务器 (proxy)
> 一个既做服务器又做客户端的中介程序，其功能是代表其他客户端发出请求。这种请求可能由代理服务器内部提供服务，或者经过一些转译传输给其他服务器。本文规定，代理服务器必须(MUST)实现客户端和服务器两方的要求(Requirements)。
#### 网关 (gateway)
> 服务器们之间的中介服务器。不同于代理(Proxy)，网关在接受请求时，会表现的像被请求资源的源服务器一样。所以，发出请求的客户端不会意识到自己正在与网关交互。
#### 隧道 (tunnel)
> 充当两个连接之间盲目中继(blind relay)的中介程序。即使隧道可能由 HTTP 请求创建，但被激活后，隧道也不算作 HTTP 交互的一部分。在两个连接都被关闭后，隧道也随之消失
#### 高速缓存 (cache)
> 程序响应信息的本地存储，以及控制该消息存储，恢复和删除的子系统的统称。高速缓存存储可缓存的(cacheable)响应信息是为了在以后再进行相同请求时，缩短响应时间，减小网络带宽消耗。所有客户端和服务器都可能包含高速缓存，尽管高速缓存不能被通道服务器所使用。
#### 可缓存的 (cacheable)
> 如果一个响应信息允许高速缓存存储一个该响应信息的副本，来用于应答以后的请求，那么这个响应信息为可缓存的。HTTP 响应的可缓存性规则定义在第13节。即使资源是可缓存的，在特殊的请求中也可能会存在关于高速缓存是否可以使用已缓存副本的附加约束。
#### 第一手的 (first-hand)
> 如果一个响应信息从源服务器直接发出，没有经过代理产生不必要的延时而直接到达，那么这个响应信息被称为第一手的。如果响应信息的有效性仅被源服务器直接检查，这个响应信息也被称为第一手的。
#### 明确终止时间 (explicit expiration time)
> 源服务器在不进行进一步验证的情况下不再允许通过高速缓存来返回实体的时间。
#### 启发式终止时间 (heuristic expiration time)
> 在没有明确终止时间的情况下，由高速缓存指定的终止时间。
#### 年龄 (age)
> 响应信息的年龄是，从它被源服务器发出或成功验证到现在的时间。
#### 寿命 (freshness lifetime)
> 响应信息从产生时间到终结时间经历的时间长度。
#### 鲜活 (fresh)
> 如果响应信息的年龄没有超过它的寿命，那么他是鲜活的。
#### 陈旧 (stale)
> 如果响应信息的年龄已经超过它的寿命，那么他是陈旧的。
#### 语义透明 (semantically transparent)
> 当缓存的使用对客户端和源服务器都没有影响时，除非为了提高性能，对于特定响应，缓存以"语义透明"的方式运行。当缓存语义透明时，客户端会接收到与请求直接被源服务器直接处理后返回的响应相同的响应(除了逐段转接的报头部分)。
#### 检验器 (validator)
> 用来核实缓存实体与实体等效与否的协议项(如：实体标签，最后修改时间)。
#### 上游/下游 (upstream/downstream)
> 上下游用来描述信息流：所有信息都从上游流向下游。
#### 流入/流出 (inbound/outbound)
> 指请求和响应信息的流向：流入指信息流向源服务器，流出指信息流向用户代理。

### 1.4 全局操作

HTTP 协议是一份请求/响应协议。客户端会向服务器发送一份表单，其中包含请求方法，URI，协议版本，表单后还会跟随一份 MIME 样式的消息，它包含与服务器连接相关的请求修饰符，客户端信息以及可能存在的请求主体。服务器以一个状态行作为响应，状态行包括消息的协议版本和成功或错误代码，紧随其后的是一份 MIME 样式的消息，它包含着服务器信息，实体元信息和可能存在的响应主体。HTTP 和 MIME 之间的关系在 Appendix19.4 中有描述。

大部分 HTTP 交互由用户代理创建，交互会包含一个从源服务器申请资源的请求。最简单的情况是，它可能仅仅通过用户代理(UA)和源服务器(O)之间的一条简单连接而创建完成。

>　　request chain ----------------------->  
> UA -------------------------------------------> O  
>　　<--------------------- response chain

更复杂一点的情况是，请求/响应链之间存在一个或多个中介。有三种较为常见的中介: 代理服务器，网关和隧道。代理服务器是一种转发工具，它完全接收对某 URI 的请求，重写全部或部分消息，然后将重写后的请求转发给该 URI 对应的服务器。网关是一种接收工具，他充当其他服务器的上层，必要时，会将请求翻译成下层服务器的协议。隧道是两个连接之间的中继点，它不会改变消息内容。当交互需要通过像防火墙之类的中介时，或者当中介无法理解消息内容时，就会用到隧道。

>　　request chain ------------------------------------>  
> UA -----v----- A -----v----- B -----v----- C -----v----- O  
>　　<---------------------------------- response chain

上图展示了用户代理和源服务器之间存在的 A，B，C 三个中介。穿越整条链的请求或响应信息会途径四段独立的连接。目的地十分重要，因为一些 HTTP 交互选项可能只会应用到距离最近的非隧道的临近节点，或只应用到链的终点，或应用到沿着链的所有连接。尽管上图是线性的，但其中每个节点都可以同时参与多个交互。比如，B 可能会在处理 A 发来的请求的同时，接收到很多从非 A 的客户端发来的请求，或者向很多非 C 的服务器传递请求。

交互中的每一个非隧道的部分都可能会为了处理请求而使用内部缓存。缓存的意义在于，如果沿着链的某一个节点拥有适用于当前请求的已缓存响应，那么请求/响应链就会缩短。假定有如下的场景: 用户代理向源服务器发送了某个请求，该请求的响应从源服务器出发，经过 C 到达 B 后，B 对响应进行了缓存，而后经过 A 传给用户代理，但 A 和用户代理并未对其缓存。现在，重新发送该请求，则会有如下图所示的信息传递。

>　　request chain ---------->  
> UA ------v------ A ------v------- B - - - - - - C - - - - - - O  
>　　<--------- response chain

并不是所有的响应都是可缓存的，一些请求可能包含标记着对缓存行为的特殊要求的标识符。关于缓存行为和可缓存响应的 HTTP 要求定义在第13节。

事实上，目前万维网中有各种各样的缓存和代理的结构或配置正在被实验或部署。这些系统包括: 为了节省跨洋带宽的国家级代理缓存，广播或多播缓存实体的系统，通过 CD-ROM 发布子缓存数据的组织等等。HTTP 系统通过高带宽链路在企业内部网中使用，个人数字助理(PDA)可通过低功率间歇性的无线链接来访问它。HTTP/1.1的目标是广泛支持已经部署的各种配置，同时引入协议构造，以满足那些需要构建高可靠性或至少在失败时有可靠的错误提示的网络应用的需要。

HTTP 交互总是发生在 TCP/IP 连接之上。默认的端口是 TCP 80，但其他的端口也可以使用。这不妨碍在互联网或其他网络中的任何协议上层实现 HTTP。HTTP 只是假定拥有可靠传输。任何可以提供这种保证的协议，HTTP都可以使用。HTTP/1.1 请求和响应结构到问题中协议传输数据单元的映射已经超出了本规定的范围。

在 HTTP/1.0 中，大部分实现在每一次请求/响应交互时都会创建一个新的连接。在 HTTP/1.1 中，一个连接可能会被一个或多个请求/响应交互使用，尽管连接可能会被各种原因关闭(见第8.1节)。

## 2. 符号惯例和基本语法

### 2.1 扩充版巴克斯-诺尔范式
本文档定义的所有机制都以散文和扩充版巴克斯-诺尔范式(使用在 RFC 822 中)的形式进行描述。理解本文档，要求使用者熟悉这些标记符号表示法。扩充版巴克斯-诺尔范式包括以下几种结构: 

#### 名称 = 定义
> 名称不附加任何 "<" 和 ">"，只包含名称本身，"=" 将其与定义分隔开。定义中续行行首的空白缩进表示该定义一行写不下，需要跨越多行进行描述，这是空白符的唯一重要意义。某些基本规则会使用大写字母，比如 SP, LWS, HT, CRLF, DIGIT, ALPHA 等等。定义中，可以将规则名称放在尖括号中，以方便人们识别。

#### "引用"
> 引号需要围绕在引用文字周围。除有特殊情况外，引用文字一般对外界不敏感。

#### 规则1 | 规则2
> 由 "|" 分隔开的项是或的关系，如 "yes | no" 表示接受 yes 或 no。

#### (规则1 规则2)
> 圆括号的内容将整体被当做一个单一的个体看待，如 "(elem (foo | bar) elem)" 表示 "elem foo elem" 和 "elem bar elem"。